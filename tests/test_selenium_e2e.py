"""
End-to-end tests using Selenium to validate PDF generation workflow.

These tests verify that:
1. PDF generation works from both home page and form view
2. Progress bar displays correctly (no NaN%)
3. PDF is successfully generated and downloadable
4. Error handling works properly
"""

import os
from pathlib import Path
import time
from unittest.mock import Mock, patch

import pytest
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.ui import WebDriverWait
from webdriver_manager.chrome import ChromeDriverManager


class TestPDFGenerationE2E:
    """End-to-end tests for PDF generation workflow."""

    @pytest.fixture(scope="class")
    def driver(self):
        """Set up Chrome WebDriver with appropriate options."""
        chrome_options = Options()
        chrome_options.add_argument("--headless")  # Run headless for CI
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--disable-gpu")
        chrome_options.add_argument("--window-size=1920,1080")

        # Set download directory
        download_dir = str(Path(__file__).parent / "downloads")
        os.makedirs(download_dir, exist_ok=True)

        prefs = {
            "download.default_directory": download_dir,
            "download.prompt_for_download": False,
            "download.directory_upgrade": True,
            "safebrowsing.enabled": True,
        }
        chrome_options.add_experimental_option("prefs", prefs)

        # Install and setup ChromeDriver
        service = Service(ChromeDriverManager().install())
        driver = webdriver.Chrome(service=service, options=chrome_options)
        driver.implicitly_wait(10)

        yield driver
        driver.quit()

        # Clean up downloads
        download_path = Path(download_dir)
        if download_path.exists():
            for file in download_path.glob("*"):
                file.unlink()
            download_path.rmdir()

    @pytest.fixture
    def app_url(self):
        """Base URL for the application."""
        return os.getenv("APP_URL", "http://localhost:8000")

    @pytest.fixture
    def sample_memo_content(self):
        """Sample memo content for testing."""
        return """ORGANIZATION_NAME=4th Engineer Battalion
ORGANIZATION_STREET_ADDRESS=588 Wetzel Road
ORGANIZATION_CITY_STATE_ZIP=Colorado Springs, CO 80904
OFFICE_SYMBOL=ABC-DEF-GH
AUTHOR=Joseph C. Schlessinger
RANK=1LT
BRANCH=EN
TITLE=Test Officer
MEMO_TYPE=MEMORANDUM FOR RECORD
SUBJECT=Selenium Test Memo

- This is a test memo generated by Selenium automation.
- It validates that PDF generation works correctly.
- Point of contact is the undersigned at (719) 555-0123."""

    def wait_for_element(self, driver, by, value, timeout=10):
        """Wait for an element to be present and return it."""
        return WebDriverWait(driver, timeout).until(
            expected_conditions.presence_of_element_located((by, value))
        )

    def wait_for_clickable(self, driver, by, value, timeout=10):
        """Wait for an element to be clickable and return it."""
        return WebDriverWait(driver, timeout).until(
            expected_conditions.element_to_be_clickable((by, value))
        )

    def wait_for_progress_modal(self, driver, should_be_visible=True, timeout=10):
        """Wait for progress modal to appear or disappear."""
        if should_be_visible:
            return WebDriverWait(driver, timeout).until(
                expected_conditions.visibility_of_element_located((By.ID, "progress-modal"))
            )
        else:
            return WebDriverWait(driver, timeout).until(
                expected_conditions.invisibility_of_element_located((By.ID, "progress-modal"))
            )

    def check_progress_text(self, driver):
        """Check that progress text is not NaN% and is reasonable."""
        progress_text = driver.find_element(By.ID, "progress-percentage")
        text_content = progress_text.text

        # Should not be NaN%
        assert "NaN%" not in text_content, f"Progress shows NaN%: {text_content}"

        # Should be either a percentage or "Processing..."
        assert text_content == "Processing..." or (
            text_content.endswith("%") and text_content[:-1].replace(".", "").isdigit()
        ), f"Invalid progress text: {text_content}"

        return text_content

    @patch("app.create_memo.delay")
    def test_pdf_generation_home_page(
        self, mock_celery_task, driver, app_url, sample_memo_content
    ):
        """Test PDF generation from the main home page editor."""
        # Mock Celery task
        mock_task = Mock()
        mock_task.id = "test-task-123"
        mock_celery_task.return_value = mock_task

        # Navigate to home page
        driver.get(app_url)

        # Wait for page to load and find the editor
        editor = self.wait_for_element(driver, By.ID, "editor")
        assert editor.is_displayed()

        # Clear and input memo content
        editor.clear()
        editor.send_keys(sample_memo_content)

        # Find and click the "Create Memo PDF" button
        create_button = self.wait_for_clickable(driver, By.ID, "start-bg-job")
        assert create_button.is_displayed()
        assert "Create Memo PDF" in create_button.text

        # Click to start PDF generation
        create_button.click()

        # Wait for progress modal to appear
        progress_modal = self.wait_for_progress_modal(driver, should_be_visible=True)
        assert progress_modal.is_displayed()

        # Check progress text is not NaN%
        progress_text = self.check_progress_text(driver)
        assert progress_text in ["Processing...", "0%"], (
            f"Unexpected initial progress: {progress_text}"
        )

        # Verify Celery task was called
        mock_celery_task.assert_called_once()

        # Check that form data was submitted correctly
        call_args = (
            mock_celery_task.call_args[1]
            if mock_celery_task.call_args[1]
            else mock_celery_task.call_args[0]
        )
        assert sample_memo_content.replace("\n", "\r\n") in str(
            call_args
        ) or sample_memo_content in str(call_args)

    @patch("app.create_memo.delay")
    def test_pdf_generation_form_view(self, mock_celery_task, driver, app_url):
        """Test PDF generation from the form builder view."""
        # Mock Celery task
        mock_task = Mock()
        mock_task.id = "test-task-456"
        mock_celery_task.return_value = mock_task

        # Navigate to form page
        driver.get(f"{app_url}/form")

        # Wait for form to load
        form = self.wait_for_element(driver, By.ID, "memo")
        assert form.is_displayed()

        # Fill in required form fields
        form_fields = {
            "ORGANIZATION_NAME": "Test Battalion",
            "ORGANIZATION_STREET_ADDRESS": "123 Test St",
            "ORGANIZATION_CITY_STATE_ZIP": "Test City, ST 12345",
            "OFFICE_SYMBOL": "TEST-OPS",
            "AUTHOR": "Test Author",
            "RANK": "CPT",
            "BRANCH": "EN",
            "SUBJECT": "Selenium Form Test",
            "MEMO_TEXT": "- This is a test memo from the form builder.\n- It validates form-based PDF generation.",
        }

        for field_id, value in form_fields.items():
            field = self.wait_for_element(driver, By.ID, field_id)
            field.clear()
            field.send_keys(value)

        # Find and click the submit button (should be a submit button in the form)
        submit_button = self.wait_for_clickable(
            driver, By.CSS_SELECTOR, "input[type='submit'], button[type='submit']"
        )
        assert submit_button.is_displayed()

        # Click to start PDF generation
        submit_button.click()

        # Wait for progress modal to appear
        progress_modal = self.wait_for_progress_modal(driver, should_be_visible=True)
        assert progress_modal.is_displayed()

        # Check progress text is not NaN%
        progress_text = self.check_progress_text(driver)
        assert progress_text in ["Processing...", "0%"], (
            f"Unexpected initial progress: {progress_text}"
        )

        # Verify Celery task was called
        mock_celery_task.assert_called_once()

    @patch("app.create_memo.delay")
    def test_progress_bar_no_nan_error(
        self, mock_celery_task, driver, app_url, sample_memo_content
    ):
        """Specific test to ensure progress bar never shows NaN%."""
        # Mock Celery task
        mock_task = Mock()
        mock_task.id = "test-task-789"
        mock_celery_task.return_value = mock_task

        # Navigate to home page
        driver.get(app_url)

        # Input content and start generation
        editor = self.wait_for_element(driver, By.ID, "editor")
        editor.clear()
        editor.send_keys(sample_memo_content)

        create_button = self.wait_for_clickable(driver, By.ID, "start-bg-job")
        create_button.click()

        # Wait for progress modal
        self.wait_for_progress_modal(driver, should_be_visible=True)

        # Monitor progress text for several seconds
        start_time = time.time()
        while time.time() - start_time < 5:  # Monitor for 5 seconds
            progress_text = self.check_progress_text(driver)

            # The main assertion - should never see NaN%
            assert "NaN%" not in progress_text, (
                f"Found NaN% in progress text: {progress_text}"
            )

            time.sleep(0.5)  # Check every 500ms

    def test_form_validation_errors(self, driver, app_url):
        """Test that form validation works and shows appropriate errors."""
        # Navigate to form page
        driver.get(f"{app_url}/form")

        # Wait for form to load
        self.wait_for_element(driver, By.ID, "memo")

        # Try to submit empty form
        submit_button = self.wait_for_clickable(
            driver, By.CSS_SELECTOR, "input[type='submit'], button[type='submit']"
        )
        submit_button.click()

        # Should either show HTML5 validation or stay on the same page
        # (depending on the validation implementation)
        current_url = driver.current_url
        assert "/form" in current_url or current_url.endswith("/form")

    def test_navigation_between_views(self, driver, app_url):
        """Test navigation between home page and form view works correctly."""
        # Start at home page
        driver.get(app_url)

        # Should have editor
        editor = self.wait_for_element(driver, By.ID, "editor")
        assert editor.is_displayed()

        # Navigate to form view (look for a link or button)
        try:
            form_link = self.wait_for_clickable(driver, By.PARTIAL_LINK_TEXT, "Form")
            form_link.click()
        except Exception:
            # Fallback: navigate directly
            driver.get(f"{app_url}/form")

        # Should now be on form page with form elements
        form = self.wait_for_element(driver, By.ID, "memo")
        assert form.is_displayed()

        org_name_field = self.wait_for_element(driver, By.ID, "ORGANIZATION_NAME")
        assert org_name_field.is_displayed()


@pytest.mark.slow
class TestPDFGenerationIntegration:
    """Integration tests that require a running server."""

    @pytest.fixture(scope="class")
    def server_running(self):
        """Check if development server is running."""
        import requests

        try:
            response = requests.get("http://localhost:8000", timeout=5)
            if response.status_code == 200:
                return True
        except requests.RequestException:
            pass

        pytest.skip(
            "Development server not running. Start with: docker-compose -f docker-compose-dev.yaml up"
        )

    def test_full_pdf_workflow_integration(self, server_running):
        """Integration test with real server - requires manual verification."""
        # This test requires a running server and would generate real PDFs
        # Mark as slow and skip in CI unless specifically requested
        pytest.skip("Full integration test - run manually with live server")
